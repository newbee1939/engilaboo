究極に分かりやすくする

・RSC(React Server Components)って最近よく聞くけど、どんなものなのか分かっていない。。
・RSC と App Router ってどういう関係なんだろう？
・そろそろキャッチアップしとかないとマズイよな。。

今回はこういった声にお答えします。

なるべく丁寧に解説するので、少しでも参考になれば幸いです。

## React Server Components と App Router を今度こそちゃんと理解する

いきなり RSC の深いところから話しても難しいと思うので、順を追って説明していきます。

まずは React と Next.js についてです。

### React と Next.js について

React とは、UI を簡単に構築するための JavaScript ライブラリです。

「コンポーネント」という概念を使って宣言的に UI を定義することで、簡単に画面の構築を行うことができます。

そして、Next.js とは React のフレームワークです。

React の機能をさらに拡張してより使いやすくしたものと捉えて良いでしょう。

### React のレンダリング方式について

React は、Create React App で作成された状態では、CSR（クライアントサイドレンダリング）でレンダリングを行います。

CSR とは、ブラウザ上で JavaScript を実行して DOM を生成しコンテンツを表示させる方法です。（全てのコンテンツをクライアントサイドでレンダリングする）

ページの初期ロード時にはコンテンツは何も表示されず（白い画面）、ブラウザでの JavaScript の実行後に画面が表示されます。

React でのレンダリングは、以下のステップで行われます。

[図を描く]

参考: https://react.dev/learn/render-and-commit

1. レンダリングのトリガーを検知

レンダリングのきっかけとなるトリガーを検知します。

ここでのトリガーとは、以下の二つです。

- コンポーネントの初期レンダリング
- コンポーネントの状態（state）の更新

このいずれかのトリガーを検知したとき、React はレンダリングを開始します。

2. コンポーネントのレンダリング

次に、実際にレンダリングを行います。

React における「レンダリング」は主に以下の３つを行います。

- 1. 対象のコンポーネントの呼び出し
- 2. 以前のコンポーネントの状態との比較
- 3. コミット（ブラウザレンダリング）する内容の決定

1 の対象のコンポーネントについて、最初のレンダリングでは、ルートコンポーネントを呼び出し、それ以降のレンダリングでは、状態更新がレンダリングのトリガーとなった関数コンポーネントを呼び出します。

そして 2 で以前のコンポーネントの状態との差分を計算し、（そもそも画面を更新するか否かも含めて）画面更新の内容を決定します。

そして、差分が検知されて画面を更新する必要がある場合、次の手順 3 を実行します。

つまり、React におけるレンダリングとは、「レンダリング対象のコンポーネントを呼び出して前回の内容との差分を比較し、何をブラウザレンダリング（Commit）をするかを決定すること」と言えるでしょう。

同じ「レンダリング」という名前が付いているので混同しがちですが、「ブラウザレンダリング（画面への描画）」とは違う概念なのでしっかりと区別するようにしましょう。

順番としては、「React のレンダリング」をした後に「ブラウザのレンダリング」を行なっているイメージです。

3. Committing to the DOM

React は 2 で以前の状態との差分があった場合、その差分をコミット（変更を DOM に適用）します。

つまり、DOM ツリーの構造の修正を行います。

この 3 つの流れについて、React の公式ではレストランを例にして解説されています。

とても分かりやすいのでぜひこちらも読んでみてください。

https://react.dev/learn/render-and-commit#epilogue-browser-paint

そして、React によるこの 3 つの処理が行われた後、ブラウザはその変更を画面に適用します。（ブラウザレンダリング）

コメント: 公式では React のレンダリングとブラウザレンダリングを区別するためにブラウザレンダリングは「ペイント」と呼ばれています

以上の流れにより、画面の表示や更新が行われます。

### Next.js のレンダリングについて

次に、Next.js のレンダリング方式についてまとめていきます。

2023 年 8 月現在、Next.js には二つのモード（タイプ）があります。

Pages Router と App Router です。

参考: https://nextjs.org/docs/pages/building-your-application/rendering

最初に Pages Router でのレンダリングについてまとめていきます。

### Next.js のレンダリングについて(Pages Router)

デフォルトでは、Next.js はすべてのページを「プリレンダリング」します。

プリレンダリングとは、Next.js が各ページの HTML をクライアントサイド JavaScript で生成するのではなく、あらかじめ生成しておくことです。

このプリレンダリングにより、パフォーマンスと SEO が向上すると言われています。

生成された HTML は必要な JavaScript コードと関連づけられており、ページがブラウザによってロードされると、その JavaScript コードが実行され、ページが完全にインタラクティブになります。（これをハイドレーションと言います）

Next.js（の Pages Router）には以下の 2 種類のプリレンダリング方式があり、状況に応じて使い分けることができます。

- 静的生成(Static Generation)
  - HTML はビルド時に生成され、リクエストごとに再利用される
- サーバサイドレンダリング(Server-side Rendering)
  - HTML はリクエストごとに生成される

### ハイドレーションとは何か？

ハイドレーションとは、サーバー側からレンダリングされた HTML に紐付けられた JavaScript を実行し、対象のページを完成された状態にすることです。

要はこういう流れです。

1. (SSR などで)サーバー側から HTML が返る
2. クライアントに送信された JavaScript を実行する(イベントリスナの登録やインタラクティブな動作の追加)

サーバから受け取った初期 HTML は、インタラクティブな機能を持たない乾いた HTML で、そこに、クライアント側で水分（必要な設定や機能）を加えてやるイメージです。

主に SSR のようにサーバー側で HTML を生成して返す場合に使用されます。

次にこの Static Generation と Server-side Rendering を含めた Next.js（Pages Router）のレンダリング種別について解説していきます。

### Next.js のレンダリング種別について(Pages Router)

React の場合は基本的には CSR での描画を行なっていましたが、Next.js（の Pages Router）では以下のように様々なレンダリング方式を選択できます。

- SSR
- SSG
- ISR
- CSR

それぞれを簡単に解説していきます。

#### SSR(Server-side Rendering)

[画像貼る]

SSR は Dynamic Rendering とも言われています。

ページの HTML がリクエストごとに生成される方式です。

サーバー側で生成された生の HTML が JavaScript の実行前にブラウザで表示されるため、画面の初期表示速度を速めることができます。

これはユーザー体験の向上はもちろんのこと、SEO にも効果があると言われています。

ページにサーバサイド・レンダリングを使用するには、getServerSideProps という非同期関数をエクスポートします。

comment: この SSR とその図は後の RSC でも出てくるので覚えておいてください。

#### SSG(Static Site Generation)

SSG を使用する場合、ページの HTML はビルド時に生成されます。

この HTML はリクエストごとに再利用され、CDN によってキャッシュすることも可能です。

Next.js ではデータが存在しないページ（静的 HTML）だけでなく、getStaticProps や getStaticPaths を使用して build 時にデータを取得・登録して HTML を生成することもできます。

SSG ではリクエストのたびにサーバーがページをレンダリングする必要がないため、レンダリングが非常に高速なのが特徴です。

そのため、基本的にはレンダリング方式として SSG の使用が推奨されています。

memo: SSG は SSR に対する最適化とも入れるかもしれません。

#### ISR(Incremental Static Regeneration)

SSG は、事前にページを生成しておき、リクエストごとにその静的なコピーを提供する手法ですが、ISR はこれを更に進化させたものです。

ISR を使うことで、静的ページがあらかじめ生成された後も、一定の時間間隔でそのページを再生成することができます。

これにより、SSG による高速レスポンスを実現しつつも、ある程度のリアルタイム性も提供することができます。

ISR の実装は、Next.js のページごとに revalidate というパラメータを設定することで行います。
このパラメータには、再生成の間隔を指定します。例えば、revalidate: 60 と設定すると、60 秒ごとにページが再生成されます。

つまり、ISR は、静的なコンテンツを効果的に提供しつつ、定期的に最新の情報を反映させる仕組みを提供する機能です。

コメント: SSR と SSG の間の技術と捉えてもいいかもしれません

#### CSR

CSR は（先ほど説明した）React のデフォルトのレンダリング方式です。

ブラウザ上で JavaScript を実行して DOM を生成しコンテンツを表示させます。

Next.js では useEffect フックを使用するなどして CSR を実装することができます。

参考 1: https://nextjs.org/docs/app/building-your-application/rendering
参考 2: https://nextjs.org/docs/pages/building-your-application/rendering

次に、いよいよ Pages Router に続く Next.js 二つ目のモードである、App Router について解説していきます。

ただ、App Router を理解するためには、そのベースの技術である RSC（React Server Components）を理解する必要があります。

そのため、まずは「RSC とは何か」について説明していきます。

### RSC（React Server Components）とは何か？

もともとの React には、先ほど説明した CSR しかありませんでした。

しかし、CSR の場合、クライアントに全てのコンポーネントのリソース（JavaScript）を送信する必要があり、クライアントのパフォーマンスが懸念されていました。

そこで誕生したのが、RSC（React Server Components）です。

RSC とは、一言で言うと、コンポーネントを「サーバー側でレンダリングされるコンポーネント」と「クライアント側でレンダリングされるコンポーネント」に分ける技術です。

これまで React には「クライアントコンポーネント」しかありませんでしたが、RSC では、どのコンポーネントをサーバー専用にし、どのコンポーネントにクライアントサイドのインタラクティブ性が必要かを選択できます。

[画像貼る]

元々は以下のように、クライアント側でのみ、レンダリングが行われていました。

[画像貼る]

これが、以下のように、サーバー側とクライアント側の両方でレンダリングが行われるようになります。

[画像貼る]

流れは以下の通りです。

1. サーバーコンポーネントのレンダリング
   サーバーはサーバーコンポーネントをレンダリングし、その出力をデータのストリームとしてクライアントに送信します。出力には、どのクライアントコンポーネントをブラウザ上でレンダリングする必要があるかという情報と、そのプロップが含まれます。

2. クライアントコンポーネントのレンダリング
   クライアントはサーバーからデータのストリームを受信し、ReactDOM を使用してクライアントコンポーネントをレンダリングします。クライアントはまた、どのサーバーコンポーネントがレンダリング済みで、どれがまだ保留中かを追跡します。

RSC により、クライアント側に送信する JavaScript のサイズ（bundle サイズ）が減少するため、パフォーマンスが向上すると言われています。

さらに、以下のような特徴があります。

・サーバー側からより高速にデータ取得が可能になる
・console.log はブラウザのコンソールではなく、サーバーのコンソールに情報を記録する
・状態管理（useState）と効果管理（useEffect）は使用できない
・サーバーコンポーネントはクライアントコンポーネントをインポートしてレンダリングできまるが、クライアントコンポーネントはその中のサーバーコンポーネントをレンダリングできない

comment: ただし、RSC を使えば無条件にサイズが減少するというわけではないようです。詳しくは以下を参考にしてください。https://qiita.com/uhyo/items/06b0cd7292256f66d7b7

### App Router とは何か？

App Router とは Next.js13 で追加された、新しいルーターの実装です。（Next.js の新しいバージョン）

App Router では、デフォルトで RSC（React Server Components）が適用されます。

つまり、作成したコンポーネントがサーバー側で実行されるということです。

クライアント側で実行させるには、`use client` を定義する必要があります。

comment: できるだけサーバー側に処理を寄せることで、パフォーマンスの改善を図るという意図が読み取れます。

現在では、Pages Router より App Router の利用が推奨されています。

App Router には他にも様々な機能がありますが、この記事では省略します。

### SSR と App Router(RSC)の違いについて

一言で理解する React: https://zenn.dev/uhyo/articles/react-server-components-multi-stage

RSC はフレームワークを介して使うことが多い。
フレームワークは普通 SSR もサポートしているので、実用上は RSC と SSR を併用することが多い。

RSC と SSR は併用される。

ここが SSR 要素。
本来クライアント側で行うレンダリングをサーバー側でも行う

!!tech-memo の uhyo さんの写真!! ↑
SSR というのは、全部をただの HTML にしてしまって、それをブラウザに送ることで、最初に JavaScript を実行しなくてもペインティングされる。
その目的のためにクライアント側も全部 HTML 文字列にしちゃう。

サーバ・コンポーネントのコードがクライアントに送られることはない。React を使った SSR の多くの実装では、コンポーネント・コードは JavaScript バンドルを通してクライアントに送られます。これはインタラクティブ性を遅らせる可能性があります。

RSC と SSR を組み合わせることで、サーバー側でクライアントコンポーネントとサーバーコンポーネントのレンダリングをし、HTML を生成した後に、クライアント側にクライアントコンポーネントの bundle javascript を送信し、ハイドレーションを行います。

つまり、SSR と RSC を組み合わせることで、初期表示を早めつつ（サーバー側でサーバーコンポーネントとクライアントコンポーネントの HTML を生成）、クライアント側に最小限の JavaScript（クライアントコンポーネント）しか送信されないようにできるため、パフォーマンスを高めることがでできます。

### SSR ト App Router(RSC)をどう使い分ける？

ややこしいので注意してほしい点は、RSC の導入後は、「SSR」とは「サーバーサイドでも stage 1 の実行を行い、生成された HTML をレスポンスに埋め込んで返すこと」を指すことになります。RSC より前の時代は SSR は「アプリケーション全体（stage 1 のみ）をサーバーサイドでも実行すること」でしたから、RSC を「サーバー側に stage 0 が追加されるもの」と考えれば理解できます。誰が何を実行するのかは次のように整理できます。

従来の SSR: Pages Router ということで、そもそも stage0(サーバー側のコンポーネント)と stage1(クライアント側のコンポーネント)の区別ない（stage1 しかない）中で、stage1 のみをサーバー側でレンダリングする

RSC のみ:サーバー側で stage 0 を実行 → クライアント側で stage 1 を実行

RSC+SSR: サーバー側で stage 0 を実行するだけでなく、サーバーサイドでも stage 1 の実行を行い、生成された HTML をレスポンスに埋め込んで返すこと

図にしてもいいかも。実験で確認できない？それぞれのサンプルをサクッと作って

rsc: https://zenn.dev/uhyo/articles/react-server-components-multi-stage

従来型（SSR なし） - : stage 1
従来型（SSR あり） stage 1 : stage 1
RSC（SSR なし） stage 0 : stage 1
RSC（SSR あり） stage 0 + stage 1 : stage 1

RSC でサーバー側で HTML 生成するのに、RSC+SSR を組み合わせる意味は？理由は？メリットは？
クライアント側の HTML も乾いた HTML としてフロントに送りたいから？
誰かに質問したい。。実験で確かめられない？

### App Router(RSC)のサンプル実装

### React の Suspense とは何か？

Suspense のサポートにより、SSR 時も非同期的なレンダリングが可能になった。(Streaming 対応 SSR)

https://eh-career.com/engineerhub/entry/2023/07/14/093000

とはいえ、理解すべきことはたった一つです。Suspense では（より正確に言えば React 18 の Concurrent Rendering という機能では）、コンポーネントそのものが「ローディング中なのでまだレンダリングできない」という状態になることがあります。

https://www.youtube.com/watch?v=WHMm6w41_WI&ab_channel=TimeeEngineering

https://qiita.com/uhyo/items/bbc22022fe846fd2b763

https://prismic.io/blog/what-is-react-suspense

### まとめ

分かりやすく。ここでか見たら分かるようにする。

### 参考資料

## 既存のアプリの Pages Router から App Router への移行を試してみる..!

勉強になりそう。

## React の RSC のチュートリアル、公式など

## App Router のチュートリアル、公式など

---

- 同じ画面を App Router, SSR, SSG とかで試してみる

※全ての資料を読んで完璧にする
※ChatGPT で誤字脱字の修正
※ブログと Qiita に同じ内容投稿すればいいやん（ちょっと変えてもいいし）
※網羅性を高める
※ユーザー視点。何が知りたいか？ISR とか必要？
※YouTube とかも
※これを参考にブログにまとめたものを参考に LT 資料作る
※具体例も載せるようにする

RSC 使っても転送量は減らないかも。単純な話ではない。
https://qiita.com/uhyo/items/06b0cd7292256f66d7b7

この記事とても分かりやすい。
https://www.freecodecamp.org/news/how-to-use-react-server-components/

サーバーコンポーネントとクライアントコンポーネントを二つ作って実験

これが良い: https://postd.cc/how-react-server-components-work/

Pages Router から App Router への移行
これも良い: https://www.youtube.com/watch?v=WHMm6w41_WI&ab_channel=TimeeEngineering

useEffect との組み合わせは？
